group sql;

add_item() ::= <<
INSERT INTO slickrent.item (id, item_name, item_description, price_usd_cent_per_min, rental_start, rental_end, image_uuids, user_id)
VALUES (:id, :item_name, :item_description, :price_usd_cent_per_min,:rental_start, :rental_end, :image_uuids, :user_id)
>>

retrieve_items(size, userId) ::= <<
SELECT *
FROM slickrent.item
<if(userId)> where user_id = :userId<endif>
ORDER by created_time
OFFSET :offset
<if(size)> LIMIT :size<endif>
>>

get_item() ::= <<
SELECT *
FROM slickrent.item
where id = :itemId
>>

add_user() ::= <<
INSERT INTO slickrent.user (id, username, password, access_token)
VALUES (:id, :username, :password, :access_token)
>>

get_token_by_user_id() ::= <<
SELECT access_token
FROM slickrent.user
WHERE id=:id
>>

get_user_by_username() ::= <<
SELECT *
FROM slickrent.user
WHERE username=:username
>>

get_user_by_token() ::= <<
SELECT *
FROM slickrent.user
WHERE access_token=:access_token
>>


get_user_by_username_password() ::= <<
SELECT *
FROM slickrent.user
WHERE username=:username and password=:password
>>

upsert_user_social_login(id, username, access_token, login_platform) ::= <<
WITH
platform_id AS (SELECT id from slickrent.login_platform where platform = :login_platform limit 1),
upsert AS (UPDATE slickrent.user SET  access_token=:access_token where username=:username and login_platform_id in (select * from platform_id)
RETURNING *
)
INSERT INTO slickrent.user (id, username, access_token, login_platform_id)
SELECT '<id>', '<username>', '<access_token>', (select * from platform_id) WHERE NOT EXISTS (SELECT * FROM upsert);
>>
